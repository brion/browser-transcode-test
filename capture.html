<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">

    <title>captureStream to MediaRecorder example</title>
  </head>

  <body>
    <h1>captureStream to MediaRecorder example</h1>

    <p>MP4 source (<a href="VID_20160402_215911.mp4" download>download source</a>):</p>
    <p><video class=src src="VID_20160402_215911.mp4" width=320 height=180></video></p>

    <p>Generated WebM (when ready; <a href="#" class=download download>download transcode</a>):</p>
    <p><video controls class=dst width=320 height=180></video></p>

    <pre></pre>

    <p><a href="https://github.com/brion/browser-transcode-test">github link</a></p>
  </body>
<script>

// current issues:
// * sometimes get an InvalidStateError
// * on Firefox 45, the recording keeps changing resolutions;
//   the result doesn't play in a video element!
//   (on FF 47 it plays back ok)
// * on Firefox 45 and 47 the result is very choppy;
//   recording is nowhere near frame-accurate
// * chrome lacks captureStream() support on video
// * on Firefox 45, if we ask for vp9+opus we get vp8+Vorbis
//   (on FF 47 asking for any codecs results in error!)

// define variables

var pre = document.querySelector('pre');
var myScript = document.querySelector('script');
var src = document.querySelector('.src');
var dst = document.querySelector('.dst');
var download = document.querySelector('.download');

// Use captureStream on the src video, pipe it through a MediaRecorder,
// then display the final blob into another video element.

function transcode() {
  var stream;
  var canvas, canvasDrawInterval;

  if (src.captureStreamUntilEnded) {
    stream = src.captureStreamUntilEnded();
    console.log('video.captureStreamUntilEnded supported');
  } else if (src.mozCaptureStreamUntilEnded) {
    stream = src.mozCaptureStreamUntilEnded();
    console.log('video.mozCaptureStreamUntilEnded supported');
  } else {
    //console.log('no captureStream or mozCaptureStreamUntilEnded support');
    //return;
    canvas = document.createElement('canvas');
    canvas.width = src.videoWidth;
    canvas.height = src.videoHeight;
    canvas.style.height = '0px';
    document.body.appendChild(canvas);
    stream = canvas.captureStream(30);
    canvasDrawInterval = setInterval(function() {
      canvas.getContext('2d').drawImage(src, 0, 0);
    }, 1000 / 30)
    console.log('canvas.captureStream supported');
  }

  var mediaRecorder = new MediaRecorder(stream, {
    mimeType: 'video/webm',
    videoBitsPerSecond: 5000000
  });
  var chunks = [], done = false;
  mediaRecorder.addEventListener('dataavailable', function(event) {
    //console.log('chunk!', event.data);
    chunks.push(event.data);

    if (done) {
      console.log('done!');
      var blob = new Blob(chunks),
        url = URL.createObjectURL(blob);
      dst.src = url;
      download.href = url;
    }
  });

  src.play();
  src.addEventListener('play', function() {
    console.log('starting');
    mediaRecorder.start();
  });
  src.addEventListener('ended', function() {
    console.log('ending');
    done = true;
    mediaRecorder.stop();
    if (canvasDrawInterval) {
      clearInterval(canvasDrawInterval);
    }
  });
}

src.onloadeddata = function() {
  transcode();
};

// dump script to pre element

pre.innerHTML = myScript.innerHTML;
  </script>
</html>
